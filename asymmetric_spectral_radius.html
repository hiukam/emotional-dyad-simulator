<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Spectral Radius Surface (Symmetric / Asymmetric)</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #191919;
        --panel: #202020;
        --panel-2: #252525;
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --stroke: rgba(255, 255, 255, 0.12);
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: var(--sans);
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 14px 14px 18px;
      }
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px 16px;
      }
      h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: -0.01em;
      }
      .sub {
        margin-top: 6px;
        font-size: 12.5px;
        color: var(--muted);
        max-width: 86ch;
        line-height: 1.45;
      }
      .headright {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      button {
        cursor: pointer;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        font-family: var(--sans);
        font-size: 12.5px;
        font-weight: 650;
      }
      button.ghost {
        background: transparent;
      }
      button:active {
        transform: translateY(1px);
      }
      .card {
        margin-top: 12px;
        border: 1px solid var(--stroke);
        background: var(--panel);
        border-radius: 12px;
        overflow: hidden;
      }
      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        padding: 12px;
        border-bottom: 1px solid var(--stroke);
        background: var(--panel-2);
      }
      @media (max-width: 820px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }
      .ctl {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 10px;
      }
      .ctl > input[type="range"] {
        grid-column: 1 / -1;
      }
      .lbl {
        display: grid;
        gap: 2px;
      }
      .lbl .k {
        font-size: 12.5px;
      }
      .lbl .d {
        font-size: 11.5px;
        color: var(--muted);
      }
      input[type="range"] {
        width: 100%;
        accent-color: #66e3ff;
      }
      input[type="range"]:disabled {
        opacity: 0.55;
      }
      .val {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
        min-width: 78px;
        text-align: right;
      }
      .valinput {
        width: 86px;
        padding: 7px 8px;
        border-radius: 10px;
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.22);
        color: var(--text);
        font-family: var(--mono);
        font-size: 12px;
        text-align: right;
        box-sizing: border-box;
      }
      input[type="number"]::-webkit-outer-spin-button,
      input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type="number"] {
        -moz-appearance: textfield;
        appearance: textfield;
      }
      #plot {
        width: 100%;
        height: min(72vh, 680px);
      }
      .bottom {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
        padding: 10px 12px 12px;
        border-top: 1px solid var(--stroke);
        background: var(--panel-2);
      }
      .vstack {
        display: grid;
        gap: 8px;
        justify-items: end;
        align-content: start;
      }
      .memval {
        display: grid;
        grid-template-columns: auto auto;
        gap: 8px;
        align-items: center;
      }
      .memk {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--muted);
      }
      .hint {
        font-size: 11.5px;
        color: var(--muted);
        line-height: 1.35;
      }
      .mono {
        font-family: var(--mono);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Spectral Radius Surface</h1>
          <div class="sub" id="subtitle">
            Asymmetric mode: surface over AI parameters (<span class="mono">&alpha;<sub>2</sub>, w<sub>2</sub></span>)
            while adjusting human empathy/agency (<span class="mono">&alpha;<sub>1</sub>, w<sub>1</sub></span>).
          </div>
        </div>
        <div class="headright">
          <button id="modeToggle" class="ghost" aria-pressed="false">Mode: Asymmetric</button>
        </div>
      </header>

      <div class="card">
        <div class="controls" aria-label="Top controls">
          <div class="ctl">
            <div class="lbl">
              <div class="k">Human empathy &alpha;<sub>1</sub></div>
              <div class="d">k<sub>12</sub>=&alpha;<sub>1</sub>(1−w<sub>1</sub>)</div>
            </div>
            <input
              id="alpha1_n"
              class="valinput"
              type="number"
              min="0"
              max="1"
              step="0.01"
              value="0.75"
              aria-label="Human empathy alpha1"
            />
            <input id="alpha1" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div class="ctl">
            <div class="lbl">
              <div class="k">Human agency w<sub>1</sub></div>
              <div class="d">Higher agency reduces coupling via (1−w<sub>1</sub>)</div>
            </div>
            <input
              id="w1_n"
              class="valinput"
              type="number"
              min="0"
              max="1"
              step="0.01"
              value="0.50"
              aria-label="Human agency w1"
            />
            <input id="w1" type="range" min="0" max="1" step="0.01" value="0.50" />
          </div>
        </div>

        <div id="plot" aria-label="3D surface plot"></div>

        <div class="bottom" aria-label="Bottom memory controls">
          <div>
            <div class="hint" id="hint">
              Memory controls persistence. Instability tends to grow as <span class="mono">&rho; &rarr; 1+</span>.
            </div>
            <input id="beta1" type="range" min="0" max="0.99" step="0.01" value="0.50" />
            <input id="beta2" type="range" min="0" max="0.99" step="0.01" value="0.50" />
          </div>
          <div class="vstack" aria-label="Memory values">
            <label class="memval">
              <span class="memk">&beta;<sub>1</sub></span>
              <input id="beta1_n" class="valinput" type="number" min="0" max="0.99" step="0.01" value="0.50" aria-label="Human memory beta1" />
            </label>
            <label class="memval">
              <span class="memk">&beta;<sub>2</sub></span>
              <input id="beta2_n" class="valinput" type="number" min="0" max="0.99" step="0.01" value="0.50" aria-label="AI memory beta2" />
            </label>
          </div>
        </div>
      </div>
    </div>

    <script
      charset="utf-8"
      src="https://cdn.plot.ly/plotly-3.3.0.min.js"
      integrity="sha256-bO3dS6yCpk9aK4gUpNELtCiDeSYvGYnK7jFI58NQnHI="
      crossorigin="anonymous"
    ></script>

    <script>
      // Asymmetric linear system:
      // k12 = alpha1 * (1 - w1)      (human feels AI)
      // k21 = alpha2 * (1 - w2)      (AI feels human)
      // A = [[beta1, k12], [k21, beta2]]
      // rho(A) = max(|lambda+|, |lambda-|),
      // lambda± = tr/2 ± sqrt(((beta1-beta2)/2)^2 + k12*k21)
      //
      // Symmetric special case:
      // alpha1=alpha2=alpha, w1=w2=w, beta1=beta2=beta -> eigenvalues beta±k with k=alpha(1-w).

      const CMIN = 0.0;
      const CMAX = 1.3;
      const N = 61;

      const VIRIDIS = [
        [0.0, "#440154"],
        [0.1111111111111111, "#482878"],
        [0.2222222222222222, "#3e4989"],
        [0.3333333333333333, "#31688e"],
        [0.4444444444444444, "#26828e"],
        [0.5555555555555556, "#1f9e89"],
        [0.6666666666666666, "#35b779"],
        [0.7692307692307692, "#6ece58"],
        [0.7777777777777778, "#6ece58"],
        [0.8888888888888888, "#b5de2b"],
        [1.0, "#fde725"],
      ];

      const alpha2Vals = Array.from({ length: N }, (_, i) => i / (N - 1));
      const w2Vals = Array.from({ length: N }, (_, i) => i / (N - 1));

      // Precompute k(alpha,w) = alpha(1-w) grid (used as k21 in asym; used as k in sym).
      const kGrid = [];
      for (let yi = 0; yi < N; yi++) {
        const alpha = alpha2Vals[yi];
        const row = [];
        for (let xi = 0; xi < N; xi++) {
          const w = w2Vals[xi];
          row.push(alpha * (1 - w));
        }
        kGrid.push(row);
      }

      function fmt(x, digits = 2) {
        return Number(x).toFixed(digits);
      }

      function computeRhoGridAsymmetric(alpha1, w1, beta1, beta2) {
        const k12 = alpha1 * (1 - w1);
        const tr = beta1 + beta2;
        const halfDiff = (beta1 - beta2) / 2.0;
        const halfDiff2 = halfDiff * halfDiff;
        const base = tr / 2.0;

        const z = [];
        for (let yi = 0; yi < N; yi++) {
          const row = [];
          for (let xi = 0; xi < N; xi++) {
            const inside = halfDiff2 + k12 * kGrid[yi][xi];
            const s = Math.sqrt(Math.max(0, inside));
            const lamPlus = base + s;
            const lamMinus = base - s;
            row.push(Math.max(Math.abs(lamPlus), Math.abs(lamMinus)));
          }
          z.push(row);
        }
        return { z, k12 };
      }

      function computeRhoGridSymmetric(beta) {
        const z = [];
        for (let yi = 0; yi < N; yi++) {
          const row = [];
          for (let xi = 0; xi < N; xi++) {
            const k = kGrid[yi][xi];
            const lamPlus = beta + k;
            const lamMinus = beta - k;
            row.push(Math.max(Math.abs(lamPlus), Math.abs(lamMinus)));
          }
          z.push(row);
        }
        return z;
      }

      const elSubtitle = document.getElementById("subtitle");
      const elHint = document.getElementById("hint");
      const modeToggle = document.getElementById("modeToggle");
      const elAlpha1 = document.getElementById("alpha1");
      const elW1 = document.getElementById("w1");
      const elBeta1 = document.getElementById("beta1");
      const elBeta2 = document.getElementById("beta2");
      const elAlpha1N = document.getElementById("alpha1_n");
      const elW1N = document.getElementById("w1_n");
      const elBeta1N = document.getElementById("beta1_n");
      const elBeta2N = document.getElementById("beta2_n");

      let mode = "asymmetric"; // or "symmetric"
      let plotInitialized = false;

      const layout = {
        title: { text: "" },
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        margin: { l: 0, r: 0, t: 52, b: 0 },
        font: { color: "rgba(255,255,255,0.82)" },
        scene: {
          xaxis: {
            title: { text: "AI Agency (w\u2082)" },
            gridcolor: "rgba(255,255,255,0.08)",
            zerolinecolor: "rgba(255,255,255,0.10)",
          },
          yaxis: {
            title: { text: "AI Empathy (\u03b1\u2082)" },
            gridcolor: "rgba(255,255,255,0.08)",
            zerolinecolor: "rgba(255,255,255,0.10)",
          },
          zaxis: {
            title: { text: "\u03c1" },
            gridcolor: "rgba(255,255,255,0.08)",
            zerolinecolor: "rgba(255,255,255,0.10)",
          },
          bgcolor: "rgba(0,0,0,0)",
        },
      };

      const config = { responsive: true, displayModeBar: true };

      function syncLabels() {
        elAlpha1N.value = elAlpha1.value;
        elW1N.value = elW1.value;
        elBeta1N.value = elBeta1.value;
        elBeta2N.value = elBeta2.value;
      }

      function clamp(x, lo, hi) {
        return Math.max(lo, Math.min(hi, x));
      }

      function decimalsFromStep(stepStr) {
        const s = String(stepStr || "");
        return (s.split(".")[1] || "").length;
      }

      function normalizeToRange(rangeEl, rawValue) {
        const min = parseFloat(rangeEl.min);
        const max = parseFloat(rangeEl.max);
        const step = parseFloat(rangeEl.step || "1");
        let v = parseFloat(rawValue);
        if (!isFinite(v)) v = parseFloat(rangeEl.value);
        v = clamp(v, min, max);
        if (isFinite(step) && step > 0) v = Math.round(v / step) * step;
        const d = decimalsFromStep(rangeEl.step);
        if (d > 0) v = parseFloat(v.toFixed(d));
        return v;
      }

      function setPair(rangeEl, numberEl, value) {
        const v = normalizeToRange(rangeEl, value);
        rangeEl.value = String(v);
        numberEl.value = String(v);
      }

      function linkRangeAndNumber(rangeEl, numberEl) {
        numberEl.value = rangeEl.value;
        rangeEl.addEventListener("input", () => {
          numberEl.value = rangeEl.value;
          scheduleUpdate();
        });
        numberEl.addEventListener("change", () => {
          setPair(rangeEl, numberEl, numberEl.value);
          scheduleUpdate();
        });
        numberEl.addEventListener("blur", () => {
          setPair(rangeEl, numberEl, numberEl.value);
        });
      }

      function updatePlot() {
        const a1 = parseFloat(elAlpha1.value);
        const w1 = parseFloat(elW1.value);
        const b1 = parseFloat(elBeta1.value);
        const b2 = mode === "symmetric" ? b1 : parseFloat(elBeta2.value);

        let z;
        let titleText;
        let xTitle;
        let yTitle;
        let hover;

        if (mode === "symmetric") {
          z = computeRhoGridSymmetric(b1);
          titleText = `Symmetric \u03c1(\u03b1, w; \u03b2=${fmt(b1, 2)})`;
          xTitle = "Agency (w)";
          yTitle = "Empathy (\u03b1)";
          hover = "\u03b1=%{y:.3f}<br>w=%{x:.3f}<br>\u03c1=%{z:.3f}<extra></extra>";
        } else {
          const out = computeRhoGridAsymmetric(a1, w1, b1, b2);
          z = out.z;
          titleText =
            `Asymmetric \u03c1(\u03b1\u2082, w\u2082; \u03b2\u2081=${fmt(b1, 2)}, \u03b2\u2082=${fmt(b2, 2)})<br>` +
            `<span style="font-size:12px;color:rgba(255,255,255,0.68)">Human: \u03b1\u2081=${fmt(a1, 2)}, w\u2081=${fmt(w1, 2)}, k\u2081\u2082=${fmt(out.k12, 3)}</span>`;
          xTitle = "AI Agency (w\u2082)";
          yTitle = "AI Empathy (\u03b1\u2082)";
          hover = "\u03b1\u2082=%{y:.3f}<br>w\u2082=%{x:.3f}<br>\u03c1=%{z:.3f}<extra></extra>";
        }

        layout.title.text = titleText;

        if (!plotInitialized) {
          const surface = {
            type: "surface",
            x: w2Vals,
            y: alpha2Vals,
            z,
            cmin: CMIN,
            cmax: CMAX,
            colorscale: VIRIDIS,
            colorbar: { title: { text: "\u03c1" } },
            hovertemplate: hover,
          };
          Plotly.newPlot("plot", [surface], layout, config);
          plotInitialized = true;
          return;
        }

        Plotly.restyle("plot", { z: [z], hovertemplate: [hover] }, [0]);
        Plotly.relayout("plot", {
          "title.text": layout.title.text,
          "scene.xaxis.title.text": xTitle,
          "scene.yaxis.title.text": yTitle,
        });
      }

      function setMode(nextMode) {
        mode = nextMode;
        const isSym = mode === "symmetric";

        modeToggle.textContent = isSym ? "Mode: Symmetric" : "Mode: Asymmetric";
        modeToggle.setAttribute("aria-pressed", isSym ? "true" : "false");

        elAlpha1.disabled = isSym;
        elW1.disabled = isSym;
        elAlpha1N.disabled = isSym;
        elW1N.disabled = isSym;

        elBeta2.disabled = isSym;
        elBeta2N.disabled = isSym;
        if (isSym) setPair(elBeta2, elBeta2N, elBeta1.value);

        elSubtitle.innerHTML = isSym
          ? `Symmetric mode: surface over shared parameters (<span class="mono">&alpha;, w</span>) with a single memory <span class="mono">&beta;</span> (using <span class="mono">&beta;<sub>1</sub></span>).`
          : `Asymmetric mode: surface over AI parameters (<span class="mono">&alpha;<sub>2</sub>, w<sub>2</sub></span>) with tunable human empathy/agency (<span class="mono">&alpha;<sub>1</sub>, w<sub>1</sub></span>).`;

        elHint.innerHTML = isSym
          ? `Memory <span class="mono">&beta;</span> uses <span class="mono">&beta;<sub>1</sub></span> and locks <span class="mono">&beta;<sub>2</sub>=&beta;<sub>1</sub></span>. Instability tends to grow as <span class="mono">&rho; &rarr; 1+</span>.`
          : `Human memory <span class="mono">&beta;<sub>1</sub></span> and AI memory <span class="mono">&beta;<sub>2</sub></span> control persistence. Instability tends to grow as <span class="mono">&rho; &rarr; 1+</span>.`;

        // Keep the numeric fields consistent with any programmatic slider updates.
        syncLabels();
        updatePlot();
      }

      function scheduleUpdate() {
        if (mode === "symmetric") setPair(elBeta2, elBeta2N, elBeta1.value);
        syncLabels();
        window.clearTimeout(scheduleUpdate._t);
        scheduleUpdate._t = window.setTimeout(updatePlot, 30);
      }

      linkRangeAndNumber(elAlpha1, elAlpha1N);
      linkRangeAndNumber(elW1, elW1N);
      linkRangeAndNumber(elBeta1, elBeta1N);
      linkRangeAndNumber(elBeta2, elBeta2N);
      modeToggle.addEventListener("click", () => setMode(mode === "asymmetric" ? "symmetric" : "asymmetric"));

      setMode("asymmetric");
    </script>
  </body>
</html>
